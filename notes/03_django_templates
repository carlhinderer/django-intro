-----------------------------------------------------------
CHAPTER 3 - DJANGO TEMPLATES
-----------------------------------------------------------

- Django Template Syntax

    {{output_variable}}               # Output variable
    {% tag %}                         # Tag
    variable|filter                   # Values after | are filters



- Auto-Escaping and Erring on the Safe Side

    - By default, all Django templates are assumed to produce HTML.  For safety from various attacks in which
        unintended code is executed, all text in Django templates is escaped.

      In the case where a Django template has to output CSV, XML, JSON content, we'll have to explicitly
        disable the auto-escaping.


    - These are the characters that are auto-escaped by default:

        Original character     Escaped to
        -------------------------------------
        <                      &lt;
        >                      &gt;
        '(single quote)        '
        " (double quote)       &quot;
        &
        &amp


    - There are 3 levels of auto-escaping:

        1. Safe = None of the characters from the table are escaped.  The content is output 'as is'.

        2. Escape = All characters from the table are escaped.

        3. Auto-escape on    = Scopes in which auto-escaping is turned on or off
           Auto-escape off



- Django Template Configuration

    - The default 'TEMPLATES' variable in 'settings.py' looks like:

        TEMPLATES = [
            {
                'BACKEND': 'django.template.backends.django.DjangoTemplates',
                'DIRS': [],
                'APP_DIRS': True,
                'OPTIONS': {
                    'context_processors': [
                        'django.template.context_processors.debug',
                        'django.template.context_processors.request',
                        'django.contrib.auth.context_processors.auth',
                        'django.contrib.messages.context_processors.messages',
                    ],
                },
            },
        ]


        BACKEND                 = specifies what kind of templates to use
        DIRS and APP_DIRS       = tell Django where to locate templates
        OPTIONS                 = which context processors to enable for a Django project


    - The 'APP_DIRS' variable specifies whether to look for Django app subfolders named 'templates'
        when searching.

    - The 'DIRS' variable is used to specify a list of directories to search in for templates.



- Invalid Template Variables

    - By default, Django templates do not throw an error when they contain invalid variables.  For
        instance, if you have {{datee}} in your template when you mean to have {{date}}, no error
        will be thrown.  The value will just be an empty string after rendering.


    - To enable informing of invalid variable errors, we use the 'string_if_invalid' option.  This should only
        be used for debugging.

        # settings.py
        TEMPLATES = [
                ... ,
                'OPTIONS': {
                    'string_if_invalid': "**** WARNING INVALID VARIABLE %s ****",
                    ...
                }
        ]



- Other TEMPLATES Options

    - To omit template details from error pages:

        'OPTIONS': {
            'debug': FALSE,
            ...
        }


    - To turn off auto-escape:

        'OPTIONS': {
            'autoescape': FALSE,
            ...
        }


    - To set a template-specific file charset:

        'OPTIONS': {
            'file_charset': ...,
            ...
        }


    - To make tags or filters available to all templates, use the 'builtins' field:

        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
            'builtins': [
                 'coffeehouse.builtins',
                 'thirdpartyapp.customtags.really_useful_tags_and_filters',
            ],
        }


    - To use a custom template loader:

         'OPTIONS': {
             'loader': 'django.template.oaders.cached.Loader',
             ...
         }



- Creating Reusable Templates

    - Templates tend to have common sections that are equally used across multiple instances.  Examples
        include menus, header and footer, advertisements, etc.

      With reusable Django templates, you can define common sections on separate templates and reuse them
        inside other templates.  They also allow you to override content on a page-by-page basis if
        you need to.


    - Using {% block %} Tags

        # base.html template
        <!DOCTYPE html>
        <html lang="en">
          <head>
              <title>{% block title%}Default title{% endblock title %}</title>
                  <meta name="description" content="{% block metadescription%}{% endblock metadescription %}">
                  <meta name="keywords" content="{% block metakeywords%}{% endblock metakeywords %}">


        # extends.html template
        {% extends "base.html" %}
        {% block title %}Coffeehouse home page{% endblock title %}


    - Using The {% include %} Tag

        # Include a template in another template
        {% include "footer.html" %}

        # Pass variables to included template
        {% include "footer.html" with year="2013" copyright="Creative Commons" %}



- Built-in Context Processors

    - By default, Django templates are enabled to have access to various variables.  This eliminates the need
        to constantly declare widely used variables in every Django view or as url extra options.  These
        variables are made available through template context processors.

      Django template context processors are explicitly defined in a project's 'settings.py' file.  


    - By default, new Django projects are enabled with 4 context processors:

        1. Django Debug Context Processor

             - Used for debugging
             - Variables: 
                 'debug' = value of DEBUG in 'settings.py'
                 'sql_queries' = database connection details run by backing method view

        2. Django Request Context Processor

             - Exposes variables related to request
             - Variables:
                 'request.GET.' = contains a request's HTTP GET parameters
                 'request.POST.' = contains a request's HTTP POST parameters
                 'requets.COOKIES.' = contains a request's HTTP COOKIES
                 'request.CONTENT_TYPE' = contains a request's HTTP Content-type header
                 'request.META' = contains a request's HTTP META data
                 'request.REMOTE_ADDR' = contains a request's HTTP remote address

        3. Django Auth Context Processor

             - Exposes variables related to authentication logic
             - Variables:
                 'user' = contains username, email
                 'perms' = contains app permissions

        4. Django Messages Context Processor

             - Exposes variables related to the Django messages framework
             - Variables:
                 'messages' = contains messages added through the Django messages framework
                 'DEFAULT_MESSAGE_LEVELS' = contains mapping of level names to numbers



- Other Built-in Django Context Processors

    - Django i18n Context Processor

        - Exposes variables related to internationalization logic
        - Variables:
            'LANGUAGES'
            'LANGUAGE_CODE'
            'LANGUAGE_BIDI'

    - Django Media Context Processor

        - Exposes variables related to media resources
        - Variables:
            'MEDIA_URL'

    - Django Static Context Processor

        - Exposes a variable related to static resources
        - Variables:
            'STATIC_URL'

    - Django tz Context Processor

        - Exposes project's time zone
        - Variables:
            'TIME_ZONE'

    - Django CSRF Context Processor

        - The CSRF context processor adds the 'csrf_token' variable to all requests.  This variable is
            used by the {% csrf_token %} template tag to protect against Cross Site Request Forgeries.

          Due to its security significance, the CSRF context processor is always enabled and cannot be
            disabled.



- Custom Context Processors

    - A Django custom context processor is structured like a regular Python method with an 'HttpRequest'
        argument.  It returns a dictionary.

        # Custom context processor
        def onsale(request):
            # Create fixed data structures to pass to template
            sale_items = {'Monday':'Mocha 2x1','Tuesday':'Latte 2x1'}
            return {'SALE_ITEMS': sale_items}


    - Also, the context processor must be added to the 'settings.py'.

        # settings.py
        'OPTIONS': {
            'context_processors': [
                'coffeehouse.stores.processors.onsale',
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        }


    - Now, the custom 'SALE_ITEMS' key becomes available to all Django templates.



- Built-in Django Filters

    - Django filters are designed to formate template variables.  The '|' pipe operator is used to apply 
        Django filters.  

        # Use a filter on a variable
        {{ variable | filter }}

        # Chain filters
        {{ variable | filter | filter }}


    - The 'date' filter takes a datetime object and displays it as a date.  There are many arguments that
        can be passed in to control formatting.

        # Display a date
        {{ variable | date }}

        # Display date with formatting options
        {{ variable | date:"F jS o" }}


    - The 'time' filters format the time of a datetime object.  

        # Display a time
        {{ variable | time }}

        # Display a time interval
        {{ variable | timesince }}
        {{ variable | timesince: othervariable }}
        {{ variable | timeuntil: othervariable }}


    - These filters are available for strings, lists, and numbers:

        # 'add' filter adds values
        {{ variable  |add: 'hello world'}}

        # 'default' filter specifies a default value if variable is falsy
        {{ variable | default: 'No value' }}

        # 'default_if_none' filter specifies a default if variable is None
        {{ variable | default_if_none: 'No value' }}

        # 'length' filter obtains the length of a value
        {{ variable | length }}

        # 'length_is' evaluates whether the length of a value is equal to an argument
        {% if variable | length_is: "7" %}

        # 'make_list' creates a list from a string or number
        {% with mycharlist='mocha' | make_list %}      # ['m', 'o', 'c', 'h', 'a']
        {% with myintlist=724 | make_list %}           # ['7', '2', '4']

        # 'yes_no' maps the value of a variable from True/False/None to 'Yes'/'No'/'Maybe'
        {{ variable | yes_no }}


    - These filters are available for numbers:

        # 'divisibleby' returns whether variable is divisible by argument
        {{ variable | divisibleby: 5 }}

        # 'filesizeformat' converts a number of bytes into a file size string
        {{ variable | filesizeformat }}

        # 'floatformat' rounds a floating-point value to a specified number of decimal places
        {{ variable | floatformat: 3 }}

        # 'get_digit' outputs digits from a number variable
        {{ variable | get_digit: "1"}}       # Returns ones digit
        {{ variable | get_digit: "2" }}      # Returns tens digit

        # 'phone2numeric' converts letters in a phone number to digits
        {{ variable | phone2numeric }}