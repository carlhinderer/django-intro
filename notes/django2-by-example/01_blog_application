--------------------------------------------------------------------
CHAPTER 1 - BUILDING A BLOG APPLICATION
--------------------------------------------------------------------

- Starting an Application

    - Create a new virtual environment, and navigate to it.

        # Install django
        $ pip install django

        # Start new app
        $ django-admin startproject mysite

        mysite/
          manage.py
          mysite/
            __init__.py
            settings.py
            urls.py
            wsgi.py


        # Run initial migrations on SQLite
        $ python manage.py migrate


    - Now, we can run the development server.

        # Run server on port 8000
        $ python manage.py runserver

        # Use a different settings.py
        $ python manage.py runserver --settings=mysite.settings



- Project Settings

    DEBUG
      Turns debug mode on and off.  

    ALLOWED_HOSTS
      Not applied if DEBUG=True or tests are run.  Once the site is moved to production, you'll add
        your domain and host to this setting.

    INSTALLED_APPS
      Tells Django which applications are active for this site.

    MIDDLEWARE
      List of middleware to be executed

    ROOT_URLCONF
      Indicates Python module root URL patterns of application are defined

    DATABASES
      Dictionary containing all databases used in the project

    LANGUAGE_CODE
      Defines default language used for Django site

    USE_TZ
      Tells Django to activate/deactivate time zone support



- Projects and Applications

    - A 'project' is a Django installation with some settings.  Think of your Django project as 
        your website, which contains several applications.

      An 'application' is a group of models, views, templates, and URLs.  Applications interact with 
        the framework to provide some specific functionalities and may be reused in various projects.


    - Now, we create our first application:

        $ python manage.py startapp blog

        blog/
          __init__.py
          admin.py         # Optional file where we register models for admin site
          apps.py          # Includes main configuration of application
          migrations/
            __init__.py
          models.py
          tests.py
          views.py



- The Blog Data Schema

    - First, we create the Post model:

        # blog/models.py
        from django.db import models
        from django.utils import timezone
        from django.contrib.auth.models import User
        
        class Post(models.Model):
            STATUS_CHOICES = (
                ('draft', 'Draft'),
                ('published', 'Published'),
            )
            title = models.CharField(max_length=250)
            slug = models.SlugField(max_length=250,
                                    unique_for_date='publish')
            author = models.ForeignKey(User,
                                       on_delete=models.CASCADE,
                                       related_name='blog_posts')
            body = models.TextField()
            publish = models.DateTimeField(default=timezone.now)
            created = models.DateTimeField(auto_now_add=True)      # Saved automatically when post is created
            updated = models.DateTimeField(auto_now=True)          # Updated automatically when post is saved
            status = models.CharField(max_length=10,
                                      choices=STATUS_CHOICES,
                                      default='draft')
        
            class Meta:
                ordering = ('-publish',)
        
            def __str__(self):
                return self.title


    - And, we'll need to add our app to INSTALLED_APPS.  The 'BlogConfig' class is your application
        configuration.


        INSTALLED_APPS = [
            ... ,
            'blog.apps.BlogConfig',
        ]


    - Now, we create and apply the migrations.

        # Create blog migrations
        $ python manage.py makemigrations blog

        # Preview the generated sql
        $ python manage.py sqlmigrate blog 0001

        # Run blog migrations
        $ python manage.py migrate



- Creating an Administrative Site for your Models

    - The Django admin site is built dynamically by reading your model metadata and providing a
        production-ready interface for editing content.


    - First, we need to create a superuser, and enter an email, username, and password.

        $ python manage.py createsuperuser


    - Now, using the superuser logins, we can navigate to 

        http://localhost:8000/admin


    - Now, we need to add our blog models to the admin site.  

        # blog/admin.py
        from django.contrib import admin
        from .models import Post

        admin.site.register(Post)

      Now, we'll have a CRUD site for the Posts available.  We can create a Post to test it.



- Customizing the Admin Site

    - Now, we'll change our admin settings.

        # blog/admin.py
        from django.contrib import admin
        from .models import Post

        @admin.register(Post)
        class PostAdmin(admin.ModelAdmin):
            list_display = ('title', 'slug', 'author', 'publish', 'status')


    - Fields we can use include:

        list_display          = Sets fields to be displayed on admin page
        list_filter           = Filters to be included for fields
        search_fields         = List of searchable fields
        date_hierarchy        = Includes navigational links to search by date
        ordering              = Default order of records
        prepopulated_fields   = Default values for fields


    - Here is a more complex customization:

        @admin.register(Post)
        class PostAdmin(admin.ModelAdmin):
            list_display = ('title', 'slug', 'author', 'publish',
                               'status')
            list_filter = ('status', 'created', 'publish', 'author')
            search_fields = ('title', 'body')
            prepopulated_fields = {'slug': ('title',)}
            raw_id_fields = ('author',)
            date_hierarchy = 'publish'
            ordering = ('status', 'publish')



- Working with QuerySet and Managers

    - The DjangoORM is compatible with MySQL, PostreSQL, SQLite, and Oracle.  It is possible to have 
        multiple database connections, and you can add custom routing schemes if necessary.


    - Creating Objects

        # Run shell
        $ python manage.py shell

        # Create a new Post
        >>> from django.contrib.auth.models import User
        >>> from blog.models import Post

        >>> user = User.objects.get(username='admin')
        >>> post = Post(title = 'Another post',
                        slug = 'another-post', 
                        body = 'Post body.', 
                        author = user)
        >>> post.save()


    - Updating Objects

        >>> post.title = 'New title'
        >>> post.save()


    - Retrieving Objects

        # Doesn't execute, because QuerySets are lazy
        >>> all_posts = Post.objects.all()

        # Does execute immediately
        >>> Post.objects.all()


    - Filtering Objects

        # Filter by fields, double underscores for accessing fields of related models
        >>> Post.objects.filter(publish__year = 2017, author__username = 'admin')


        # Can exclude certain results using the 'exclude()' method of the manager
        >>> Post.objects.filter(publish__year = 2017) \
                        .exclude(title__startswith = 'Why')


    - Ordering Results

        # Ascending order
        >>> Post.objects.order_by('title')

        # Descending order
        >>> Post.objects.order_by('-title')


    - Deleting Objects

        >>> post = Post.objects.get(id = 1)
        >>> post.delete()



- When QuerySets are Evaluated

    - QuerySets are only evaluated in the following cases:

        1. The first time you iterate over them
        2. When you slice them
        3. When you pickle or cache them
        4. When you called 'repr()' or 'len()' on them
        5. When you explicitly call 'list()' on them
        6. When you test a statement, such as with 'bool', 'or', 'and', 'if'



- Creating Model Managers

    # blog/models.py
    class PublishedManager(models.Manager):
        def get_queryset(self):
            return super(PublishedManager, self) \
                   .get_queryset() \
                   .filter(status='published')

    class Post(models.Model):
        # ...
        objects = models.Manager()
        published = PublishedManager()


    # Now, we can use our model manager
    >>> Post.published.filter(title__startswith = 'Who')



- Building List and Detail Views

    - Here, we add list and detail views for posts:

        # blog/views.py
        from django.shortcuts import render, get_object_or_404
        from .models import Post

        def post_list(request):
            posts = Post.published.all()
            return render(request, 
                          'blog/post/list.html', 
                          {'posts': posts})

        def post_detail(request, year, month, day, post):
            post = get_object_or_404(Post, slug=post,
                                           status='published',
                                           publish__year=year,
                                           publish__month=month,
                                           publish__day=day)
            return render(request,
                          'blog/post/detail.html',
                          {'post': post})


    - Adding URL Patterns for your Views