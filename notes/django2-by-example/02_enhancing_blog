--------------------------------------------------------------------
CHAPTER 2 - ENHANCING THE BLOG APPLICATION
--------------------------------------------------------------------

- Sharing Posts By Email

    - First, we allow users to share posts by sending them as emails.  We need to:

        1. Create a form for users to enter their name and email, the email recipient, and 
             optional comments

        2. Create a view in the 'views.py' file that handles the posted data and sends the
             email

        3. Add a URL pattern for the new view in the 'urls.py' file

        4. Create a template to display the form



- Creating Forms with Django

    - We'll start by building the form to share posts.  We'll use Django's built-in forms
        framework.

      Django comes with 2 base classes to build forms:

        1. 'Form' = allows you to build standard forms
        2. 'ModelForm' = allows you to build forms tie to model instances

    
    - First, we create the form.  Forms can reside anywhere in a project, but the convention is to
        put them in a 'forms.py' inside each application.

        # blog/forms.py
        from django import forms

        class EmailPostForm(forms.Form):
            name = forms.CharField(max_length=25)
            email = forms.EmailField()
            to = forms.EmailField()
            comments = forms.CharField(required=False, widget=forms.Textarea)



- Handling Forms in Views

    - Now, we'll create a new view that handles the form and sends an email when it's successfully 
        submitted.  

        # blog/views.py
        from .forms import EmailPostForm
 
        def post_share(request, post_id):
            # Retrieve post by id
            post = get_object_or_404(Post, id=post_id, status='published')
        
            if request.method == 'POST':
                # Form was submitted
                form = EmailPostForm(request.POST)
                if form.is_valid():
                    # Form fields passed validation
                    cd = form.cleaned_data
                    # ... send email
            else:
                form = EmailPostForm()
            return render(request, 'blog/post/share.html', {'post': post, 'form': form})



- Sending Emails with Django

    - Sending emails with Django is pretty straightforward.  First, you need to have a local SMTP server
        or define the configuration of an external SMTP server by adding these settings to the 
        'settings.py' file:

        EMAIL_HOST = 'smtp.gmail.com'
        EMAIL_PORT = 587
        EMAIL_HOST_USER = 'your_account@gmail.com'
        EMAIL_HOST_PASSWORD = 'your_pw'
        EMAIL_USE_TLS = True
        EMAIL_USE_SSL


    - To send the email, we update the view:


        # views.py
        from django.core.mail import send_mail
        
        def post_share(request, post_id):
            post = get_object_or_404(Post, id=post_id, status='published')
            sent = False

            if request.method == 'POST':
                form = EmailPostForm(request.POST)
                if form.is_valid():
                    # Form fields passed validation
                    cd = form.cleaned_data
                    post_url = request.build_absolute_uri(post.get_absolute_url())
                    subject = '{} ({}) recommends you reading "{}"'.format(cd['name'], 
                                                                           cd['email'], 
                                                                           post.title)
                    message = 'Read "{}" at {}\n\n{}\'s comments: {}'.format(post.title, 
                                                                             post_url, 
                                                                             cd['name'], 
                                                                             cd['comments'])
                    send_mail(subject, message, 'admin@myblog.com', [cd['to']])
                    sent = True
            else:
                form = EmailPostForm()
            return render(request, 'blog/post/share.html', {'post': post, 'form': form, 'sent': sent})


    - Finally, we add the url for the email method:

        urlpatterns = [
          ... ,
          path('<int:post_id>/share/', views.post_share, name='post_share'),
        ]



- Rendering Forms in Templates

    - Now that we have created the form, added the view, and added the URL pattern, we just need to
        create the template for the view.

        # blog/templates/blog/post/share.html
        {% extends "blog/base.html" %}
        
        {% block title %}Share a post{% endblock %}
        
        {% block content %}
          {% if sent %}
            <h1>E-mail successfully sent</h1>
            <p>
              "{{ post.title }}" was successfully sent to {{ form.cleaned_data.to }}.
            </p>
          {% else %}
            <h1>Share "{{ post.title }}" by e-mail</h1>
            <form action="." method="post">
              {{ form.as_p }}
              {% csrf_token %}
              <input type="submit" value="Send e-mail">
            </form>
          {% endif %}
        {% endblock %}


    - The '{{ form.as_p }}' renders each field in the form as a <p> tag ('as_ul' and 'as_table' can also be
        used).  It also renders any validation errors next to the fields.


    - By default, Django checks for the CSRF token in all POST requests.  So, we must include the
        '{% csrf_token %}' tag in all forms submitted via POST.


    - Now, we add this link to 'detail.html':

        <p>
          <a href="{% url "blog:post_share" post.id %}">
            Share this post
          </a>
        </p>



- Creating a Comment System

    - To build a comment system for the blog, wherein the users will be able to comment on 
        posts.  We need to do the following:

        1. Create a model to save comments

        2. Create a form to submit comments and validate the input data

        3. Add a view that processes the form and saves the new comment to the database

        4. Edit the post detail template to dislay the list of comments



- Creating the Comment Model

    # blog/models.py
    class Comment(models.Model):
        post = models.ForeignKey(Post,
                                 on_delete = models.CASCADE,
                                 related_name = 'comments')
        name = models.CharField(max_length = 80)
        email = models.EmailField()
        body = models.TextField()
        created = models.DateTimeField(auto_now_add = True)
        updated = models.DateTimeField(auto_now = True)
        active = models.BooleanField(default = True)

        class Meta:
            ordering = ('created',)

        def __str__(self):
            return 'Comment by {} on {}'.format(self.name, self.post)


    # Create and run the migration
    $ python manage.py makemigrations blog
    $ python manage.py migrate


    # Register the model for the admin page
    # admin.py
    from .models import Post, Comment

    @admin.register(Comment)
    class CommentAdmin(admin.ModelAdmin):
        list_display = ('name', 'email', 'post', 'created', 'active')
        list_filter = ('active', 'created', 'updated')
        search_fields = ('name', 'email', 'body')