-----------------------------------------------------------
CHAPTER 2 - DJANGO URLS AND VIEWS
-----------------------------------------------------------

- URL Regular Expressions

    - The precedence rule is that granular urls come first, and broad urls come last.  If more than one
        URL matches the incoming request, the top one will get triggered.

        urlpatterns = [
            url(r'^about/',TemplateView.as_view(template_name='about.html')),
            url(r'^about/index/',TemplateView.as_view(template_name='index.html')),
        ]


    - Using exact patterns (which end with $) instead of wildcard matching, can make the URLs easier to
        reason about in a large application.

        urlpatterns = [
            url(r'^about/$',TemplateView.as_view(template_name='about.html')),
            url(r'^about/index/$',TemplateView.as_view(template_name='index.html')),
        ]


    - Exact patterns can end up causing extra work if you're doing SEO or A/B testing, since you'll need
        to provide an exact match for each URL you use.

        # SEO Example
        /about/the+coffeehouse+in+san+diego

        # A/B Testing Example
        /about/landing/a
        /about/landing/b



- Regex Syntax For URLs

    - Symbols

        ^              Start of URL
        $              End of URL
        \              Escape for interpreted values
        |              Or

        +              1 or more occurrences
        ?              0 or 1 occurrences
        {n}            n occurrences
        {n,m}          Between n and m occurrences

        []             Character grouping
        (?P<name>__)   Capture occurrences that matches regex __ and assign to 'name'
        .              Any character
        \d+            1 or more digits

        \D+            1 or more non-digits
        [a-zA-z0-9_]   1 character that is a letter, number, or underscore
        \w+            1 or more word characters
        [-@\w]+        1 or more word characters, dashes, and ats



    - Examples

        r'^$'                 Empty String
        r'^stores/'           /stores/ with anything after it
        r'^about/contact$'    /about/contact exactly
        r'^stores/\d+/'       /stores/ with any digit

        r'^drinks/mocha|espresso/'    /drinks/mocha or /drinks/espresso with anything after it

        r'^state/[A-Z]{2}/'           /state/ with any 2 uppercase letters after


    - Note that Django URLs do not inspect GET request query strings.



- Passing URL Parameters to Templates

    - Sometimes, we need to pass values from the URL to the view or the template layer.

        urlpatterns = [
            url(r'^drinks/(?P<drink_name>\D+)/',TemplateView.as_view(template_name='drinks/index.html'))
        ]

      In this case, we're sending the value of <drink_name> to the 'drinks/index.html' template.  We can
        refer to it there with

        {{drink_name}}


    - We can also pass parameters to a template by adding a dictionary as a parameter to 'as_view':

        url(r'^drinks/(?P<drink_name>\D+)', 
            TemplateView.as_view(template_name='drinks/index.html'), {'onsale':True})

      Then, we can refer in the template to:

        {{onsale}}



- Passing URL Parameters to Views

    - Here, we capture a URL parameter:

        from coffeehouse.stores import views as stores_views

        urlpatterns = patterns[
            url(r'^stores/(?P<store_id>\d+)/', stores_views.detail)
        ]


    - And we can refer to the <store_id> in the view.  Note that the URL parameter name must match the
        view parameter name.  Also note that any paramter passed from a URL is always a string, regardless
        of its content (ie even if its an integer).

        from django.shortcuts import render

        def detail(request, store_id):
            # We can access store_id now here
            return render(request, 'stores/detail.html')


    - Note that we can make a URL parameter optional by assigning it a default value in the view method.

        # 2 URLs, one where the parameter is passed, and one where it isn't
        urlpatterns = patterns[
            url(r'^stores/',stores_views.detail),
            url(r'^stores/(?P<store_id>\d+)/',stores_views.detail),
        ]

        # View controller method with optional parameter
        def detail(request, store_id='1'):
            return render(request, 'stores/detail.html')


    - We can pass extra paramaters to a view in a dictionary as well:

        # Pass the 'location' parameter
        url(r'^stores/',stores_views.detail,{'location':'headquarters'})

        # Must also add 'location' to view parameters
        def detail(request, store_id='1', location=None)



- Accessing Parameters from the Query String

    - For example, we receive the request:

        /stores/1/?hours=sunday&map=flash

      Here is our view method for extracting the query string parameters:

        def detail(request,store_id='1',location=None):
            hours = request.GET.get('hours', '')
            map = request.GET.get('map', '')
            # 'hours' has value 'sunday' or '' if hours not in url
            # 'map' has value 'flash' or '' if map not in url
            return render(request,'stores/detail.html')



- URL Consolidation and Modularization

    - Once a project becomes large, it can be difficult to manage all the URLs in a single file.  There
        are a few different methods to manage that complexity.


    - For example, here we use the 'include' method to include a separate module of URLs from the
        'about' app.  

        # coffeehouse/urls.py
        from django.conf.urls import include, url
        from django.views.generic import TemplateView

        urlpatterns = [
            url(r'^$',TemplateView.as_view(template_name='homepage.html')),
            url(r'^about/',include('coffeehouse.about.urls')),
            url(r'^stores/',include('coffeehouse.stores.urls'),{'location':'headquarters'}),
        ]


        # coffeehouse/about/urls.py
        from django.conf.urls import url
        from . import views

        urlpatterns = [
            url(r'^$',views.index),
            url(r'^contact/$',views.contact),
        ]


    - Another way to organize URLs is to put them in separate groups in the 'urls.py'.

        # coffeehouse/urls.py
        from django.conf.urls import include, url
        from django.views.generic import TemplateView
        
        from coffeehouse.about import views as about_views
        from coffeehouse.stores import views as stores_views
        
        store_patterns = [
            url(r'^$',stores_views.index),
            url(r'^(?P<store_id>\d+)/$',stores_views.detail),
        ]
        
        about_patterns = [
            url(r'^$',about_views.index),
            url(r'^contact/$',about_views.contact),
        ]
        
        urlpatterns = [
            url(r'^$',TemplateView.as_view(template_name='homepage.html')),
            url(r'^about/',include(about_patterns)),
            url(r'^stores/',include(store_patterns),{'location':'headquarters'}),
        ]



- URL Naming

    - A project's internal links tend to be hard-coded, which can present a serious maintenance problem.  
        Django has a way to name urls so that it's easy to reference them in view methods and templates.


        # Definition in urls.py
        url(r'^$',TemplateView.as_view(template_name='homepage.html'), name="homepage")


        # Definition in view method
        # The 'reverse' method looks up a url definition in urls.py by the 'name' attribute and substitutes it in
        from django.http import HttpResponsePermanentRedirect
        from django.core.urlresolvers import reverse

        def method(request):
            ....
            return HttpResponsePermanentRedirect(reverse('homepage'))


        # Definition in template
        <a href="{% url 'homepage' %}">Back to home page</a>


    - We can also pass parameters around when using named links.

        # Definition in urls.py
        url(r'^drinks/(?P<drink_name>\D+)/',
            TemplateView.as_view(template_name='drinks/index.html'),
            name="drink")


        # Definition in view method
        from django.http import HttpResponsePermanentRedirect
        from django.core.urlresolvers import reverse

        def method(request):
            ....
            return HttpResponsePermanentRedirect(reverse('drink', args=(drink.name,)))


        # Definition in template
        <a href="{% url 'drink' drink.name %}">Drink on sale</a>
        <a href="{% url 'drink' 'latte' %}">Drink on sale</a>


    - Beware that Django always checks at startup that all 'reverse' and '{% url %}' definitions are
        valid.  If there is a typo in these, the application won't start!



- URL Namespaces

    - We may have several 'index' or 'details' pages for different entities in our application.  We can
        use the 'namespace' attribute to allow a group of URLs to be identified with a unique
        qualifier, so that we can refer to them as named urls.


        # Main urls.py
        from django.conf.urls import include, url
        
        urlpatterns = [
            url(r'^$',TemplateView.as_view(template_name='homepage.html') ,name="homepage"),
            url(r'^about/',include('coffeehouse.about.urls', namespace="about")),
            url(r'^stores/',include('coffeehouse.stores.urls', namespace="stores")),
        ]
        

        # About urls.py
        from . import views
        
        urlpatterns = [
            url(r'^$',views.index, name="index"),
            url(r'^contact/$',views.contact, name="contact"),
        ]
        

        # Stores urls.py
        from . import views
        
        urlpatterns = [
            url(r'^$',views.index, name="index"),
            url(r'^(?P<store_id>\d+)/$', views.detail, name="detail"),
        )
        

        # Definition in view method
        from django.http import HttpResponsePermanentRedirect
        from django.core.urlresolvers import reverse
        
        def method(request):
            ....
            return HttpResponsePermanentRedirect(reverse('about:index'))
        

        # Definition in template
        <a href="{% url 'stores:index' %}">Back to stores index</a>


    - Namespaces can also be nested.

        # Definition in view method
        from django.http import HttpResponsePermanentRedirect
        from django.core.urlresolvers import reverse

        def method(request):
            ....
            return HttpResponsePermanentRedirect(reverse('stores:about:index', args=(store.id,)))


        # Definition in template
        <a href="{% url 'stores:about:index' store.id %}"> See about for {{store.name}} </a>

        

- View Method Requests

    - So far, we've used Django view methods and their input (a request object and parameters) as well as their
        output (a direct response or relying on a template to generate a response).

      Now, we'll take a deeper look at what's available in view method requests and the various alternatives to
        generate view method responses.


    - The 'request' object that is passed in to every view method is an instance of the 
        'django.http.request.HttpRequest' class.  It contains information set by entities present before a view
        method (user's web browser, web server that runs the application, or Django middleware class).

      Here are some of it's most commonly used attributes and methods:

        request.method                        # Contains HTTP method used for request

        request.GET or request.POST           # Contains parameters added as part of a GET or POST request
                                              # Parameters are enclosed in a 'django.http.request.Querydict' instance

        request.POST.get('name', default=None)       # Gets the value of the name parameter in a POST request or gets
                                                     #   None if the value is not present

        request.GET.getlist('drink', default=None)   # Gets list of values for 'drink' parameter in a GET request  or
                                                     #   gets None if the value is not present

        request.META                          # Contains HTTP headers added by browsers or a web server as part of 
                                              #   the request.  Parameters are enclosed in a dictionary where the keys
                                              #   are HTTP header names.

        request.META['REMOTE_ADDR']           # Gets a user's remote ip address

        request.user                          # Contains information about a Django user (ie username, email) linked to
                                              #   the request


    - Once we're done extracting information from a 'request' reference and doing related business logic with it, (like
        querying a database or fetching data from another REST service), we'll need to set up data in a view method to
        send it out as part of the response.  

      Once we have extracted the data we need, we create a dictionary with the data and pass it to the template.

        # views.py
        from django.shortcuts import render

        def detail(request, stored_id='1', location=None):
            STORE_NAME = 'Downtown'
            store_address = {'street':'Main #385','city':'San Diego','state':'CA'}
            store_amenities = ['WiFi','A/C']
            store_menu = ((0,''),(1,'Drinks'),(2,'Food'))
            values_for_template = {'store_name':STORE_NAME, 
                                   'store_address':store_address, 
                                   'store_amenities':store_amenities, 
                                   'store_menu':store_menu}
            return render(request, 'stores/detail.html', values_for_template)


    - Finally, we can display the variables that have been passed to the template.

        # Template
        <h4>{{store_name}}</h4>
        <p>{{store_address.street}}</p>
        <p>{{store_address.city}}, {{store_address.state}}</p>
        <hr />
        <p>We offer: {{store_amenities.0}} and {{store_amenities.1}}</p>
        <p>Menu includes : {{store_menu.1.1}} and {{store_menu.2.1}}</p>



- View Method Responses

    - The 'render()' method we've been using to generate view method responses so far has been a shortcut.  There are other
        alternatives as well.


    - There are 3 different alternatives for rendering templates from data available in the view method.

        # Option 1
        # Parameters:
        #   1. Request reference (required)
        #   2. Template route (required)
        #   3. Context dictionary (optional)
        # Optional arguments:
        #   'content_type' : sets the HTTP 'Content-Type' header, defaults to 'DEFAULT_CONTENT_TYPE' in settings.py
                                (which is 'text/html')
        #   'status'       : HTTP status code (defaults to 200)
        #   'using'        : sets template engine to be used ('jinja2' or 'django')

        from django.shortcuts import render
        
        def detail(request, store_id='1', location=None):
            ...
            return render(request, 'stores/detail.html', values_for_template)
        

        # Option 2
        # Same as Option 1, but a TemplateResponse object can alter a response through middleware.
        # Optional arguments:
        #   'content_type' : default is 'DEFAULT_CONTENT_TYPE' in settings.py
        #   'status'       : default is 200
        #   'charset'      : default is 'DEFAULT_CHARSET' in settings.py
        #   'using'        : template engine

        from django.template.response import TemplateResponse
        
        def detail(request, store_id='1', location=None):
            ...
            return TemplateResponse(request, 'stores/detail.html', values_for_template)
        

        # Option 3
        # This approach is the most flexible.  First, we create a raw HttpResponse object.  Then, we 
        #   load the template and the context separately.

        from django.http import HttpResponse
        from django.template import loader, Context
        
        def detail(request, store_id='1', location=None):
             ...
             response = HttpResponse()
             t = loader.get_template('stores/detail.html')
             c = Context(values_for_template)
             return response.write(t.render(c))



- Response Options for HTTP Status and Content-Type Headers

    - The 'Content-Type' header is used to indicate the media type of the resource.

        > In requests (ie POST or PUT), the client uses this header to tell the server what type of 
            data is sent.

        > In responses, the server uses this header to tell the client the content type of the returned
            content.


    - Here are examples of setting the Content-type and Status headers:

        from django.shortcuts import render

        # No method body(s) and only render() example provided for simplicity
        
        # Returns content type text/plain, with default HTTP 200
        return render(request,'stores/menu.csv', values_for_template, content_type='text/plain')
        
        # Returns HTTP 404, with default text/html
        # NOTE: Django has a built-in shortcut & template 404 response, described in the next section
        return render(request, 'custom/notfound.html', status=404)
        
        # Returns HTTP 500, wtih default text/html
        # NOTE: Django has a built-in shortcut & template 500 response, described in the next section
        return render(request, 'custom/internalerror.html', status=500)
        
        # Returns content type application/json, with default HTTP 200
        # Often required for applications consume AJAX requests
        # NOTE: Django has a built-in shortcut JSON response, described in the next section
        return render(request,'stores/menu.json', values_for_template, content_type='application/json')



- Built-in Response Shortcuts

    HTTP status code               Python code sample

    404 (Not Found)                from django.http import Http404
                                   raise Http404

    500 (Internal Server Error)    raise Exception

    400 (Bad Request)              from django.core.exceptions import SuspiciousOperation
                                   raise SuspiciousOperation

    403 (Forbidden)                from django.core.exceptions import PermissionDenied
                                   raise PermissionDenied



- DEBUG Setting and Error Pages

    - If 'DEBUG=True' in 'settings.py', error pages for each error with stack traces will be returned.  
      If 'DEBUG=False', just the error status will be returned.


    - We can also create custom error pages for each of the errors.

        # Route changes to urls.py

        # Overrides the default 400 handler django.views.defaults.bad_request
        handler400 = 'coffeehouse.utils.views.bad_request'

        # Overrides the default 403 handler django.views.defaults.permission_denied
        handler403 = 'coffeehouse.utils.views.permission_denied'

        # Overrides the default 404 handler django.views.defaults.page_not_found
        handler404 = 'coffeehouse.utils.views.page_not_found'

        # Overrides the default 500 handler django.views.defaults.server_error
        handler500 = 'coffeehouse.utils.views.server_error'
        
        urlpatterns = [....
        ]


        # Custom view methods
        from django.shortcuts import render

        def page_not_found(request):
            # Dict to pass to template, data could come from DB query
            values_for_template = {}
            return render(request,'404.html',values_for_template,status=404)
        
        def server_error(request):
            # Dict to pass to template, data could come from DB query
            values_for_template = {}
            return render(request,'500.html',values_for_template,status=500)
        
        def bad_request(request):
            # Dict to pass to template, data could come from DB query
            values_for_template = {}
            return render(request,'400.html',values_for_template,status=400)
        
        def permission_denied(request):
            # Dict to pass to template, data could come from DB query
            values_for_template = {}
            return render(request,'403.html',values_for_template,status=403)



- Built-in Response Shortcuts for Inline and Streamed Content

    - All the examples we've had so far render a template as a response.  Sometimes, a simple status 
        will be sufficient.

      Here are shortcuts for typical HTTP response codes:

        HTTP status code                    Python code sample

        301 (Permanent Redirect)            from django.http import HttpResponsePermanentRedirect
                                            return HttpResponsePermanentRedirect(“/”)

        302 (Redirect)                      from django.http import HttpResponseRedirect
                                            return HttpResponseRedirect(“/”)

        304 (NOT MODIFIED)                  from django.http import HttpResponseNotModified
                                            return HttpResponseNotModified()*

        400 (BAD REQUEST)                   from django.http import HttpResponseBadRequest
                                            return HttpResponseBadRequest(“<h4>The request doesn’t look right</h4>”)

        404 (NOT FOUND)                     from django.http import HttpResponseNotFound
                                            return HttpResponseNotFound(“<h4>Ups, we can’t find that page</h4>”)

        403 (FORBIDDEN)                     from django.http import HttpResponseForbidden
                                            return HttpResponseForbidden(“Can’t look at anything here”, content_type=“text/plain”)

        405 (METHOD NOT ALLOWED)            from django.http import HttpResponseNotAllowed
                                            return HttpResponseNotAllowed(“<h4>Method not allowed</h4>”)

        410 (GONE)                          from django.http import HttpResponseGone
                                            return HttpResponseGone(“No longer here”,content_type=“text/plain”)

        500 (INTERNAL SERVER ERROR)         from django.http import HttpResponseServerError
                                            return HttpResponseServerError(“<h4>Ups, that’s a mistake on our part, sorry!</h4>”)

        Inline response that serializes     from django.http import JsonResponse
        data to JSON (Defaults to HTTP 200  data_dict = {’name’:’Downtown’,’address’:’Main #385’,’city’:’San Diego’,’state’:’CA’}
        and content type application/json)  return JsonResponse(data_dict)

        Inline response that stream data    from django.http import StreamingHttpResponse
        (Defaults to HTTP 200 and           return StreamingHttpResponse(large_data_structure)
        streaming content, which is an 
        iterator of strings)
    
        Inline response that stream         from django.http import FileResponse
        binary files (Defaults to HTTP      return FileResponse(open(’Report.pdf’,’rb’))
        200 and streaming content)
    
        Inline response with any HTTP       from django.http import HttpResponse
        status code (Defaults to HTTP       return HttpResponse(“<h4>Django inline response</h4>”)
        200)
    


